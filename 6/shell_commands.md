## OS module

This module provides a portable way of using operating system dependent functionality. 

    os.name

The name of the operating system dependent module imported. The following names have currently been registered: 'posix', 'nt', 'os2', 'ce', 'java', 'riscos'.

    os.environ

A mapping object representing the string environment.


    os.chdir(path)
    os.fchdir(fd)
    os.getcwd()


    os.open(file, flags[, mode])

Open the file file and set various flags according to flags and possibly its mode according to mode.

https://docs.python.org/2/library/os.html#open-flag-constants



##Running shell commands by python

###os.popen()

### commands.*

The commands module contains wrapper functions for os.popen() which take a system command as a string and return any output generated by the command and, optionally, the exit status.


    commands.getstatusoutput(cmd)

Execute the string cmd in a shell with os.popen() and return a 2-tuple (status, output). cmd is actually run as { cmd ; } 2>&1, so that the returned output will contain output or error messages. A trailing newline is stripped from the output. The exit status for the command can be interpreted according to the rules for the C function wait().

    commands.getoutput(cmd)

Like getstatusoutput(), except the exit status is ignored and the return value is a string containing the command’s output.

    commands.getstatus(file)

Return the output of ls -ld file as a string. This function uses the getoutput() function, and properly escapes backslashes and dollar signs in the argument.


###subprocess — Subprocess management



The subprocess module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes. This module intends to replace several older modules and functions:

    os.system
    os.spawn*
    os.popen*
    popen2.*
    commands.*

he recommended way to launch subprocesses is to use the following convenience functions. 

    subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)


shell=False disables all shell based features, but does not suffer from this vulnerability


    from subprocess import call
    filename = input("What file would you like to display?\n")
    What file would you like to display?
    on_existent; rm -rf / #
    call("cat " + filename, shell=True) # Uh-oh. This will end badly...












